<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="./reactivity.global.js"></script>
    <div id="app"></div>
    <script>
        // effect表示副作用函数 如果此函数依赖的数据发生变化会触发执行
        // reactive将数据变成响应式 proxy
        const { reactive, watch } = VueReactivity;
        const state = reactive({ flag: true, name: 'jw', age: 30 });
        let i = 2000;
        function getData(timer) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(timer)
                }, timer)
            })
        }

        // 第一次调用watch时往onCleanup传入一个回调 第二次调用watch时执行上一次传入的回调
        // 1、第一次调用watch时用户注入一个取消的回调
        // 2、第二次调用watch时会执行第一次注入的回调
        // 3、第三次调回watch时会执行第二次注入的回调...
        watch(() => state.age, async(newValue, oldValue, onCleanup) => {
            let clear = false;
            onCleanup(() => {
                clear = true;
            })
            i -= 1000;
            // 第一次执行1s后渲染1000 第二次0秒后渲染0
            // 因为第二次调用了onCleanup回调时clear=false 所以第一次结果1000不会渲染
            let r = await getData(i);
            if(!clear) { document.body.innerHTML = r };
        });
        state.age = 31;
        state.age = 32;
    </script>
</body>
</html>